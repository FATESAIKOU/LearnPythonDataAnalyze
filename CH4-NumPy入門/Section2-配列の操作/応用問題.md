# Section2: 配列の操作 - 応用問題

## 🚀 この応用問題について

演習で学んだ基礎を使って、より実践的な問題に挑戦しましょう。
分からない場合は、技術説明を見直したり、AI エージェントに質問してください。

---

## 応用問題1: 成績データの抽出

### 問題

5人の生徒の3科目（国語、数学、英語）のテスト成績があります。

```python
import numpy as np

# 行: 生徒、列: 科目（国語、数学、英語）
scores = np.array([[78, 85, 72],
                   [92, 88, 95],
                   [65, 70, 68],
                   [88, 92, 85],
                   [55, 60, 58]])
```

以下を抽出してください：

1. 2番目の生徒（インデックス1）の全科目の点数
2. 数学（2列目）の全生徒の点数
3. 3番目と4番目の生徒の国語と英語の点数
4. 数学が80点以上の生徒の全データ

### 期待される出力

```
2番目の生徒: [92 88 95]
数学の点数: [85 88 70 92 60]
3-4番目の国語と英語:
[[65 68]
 [88 85]]
数学80点以上:
[[78 85 72]
 [92 88 95]
 [88 92 85]]
```

<details>
<summary>解答例を見る</summary>

**基本解法: インデックスとスライス、ブールインデックスを使用**

```python
import numpy as np

scores = np.array([[78, 85, 72],
                   [92, 88, 95],
                   [65, 70, 68],
                   [88, 92, 85],
                   [55, 60, 58]])

# 2番目の生徒（インデックス1）
print("2番目の生徒:", scores[1])

# 数学（2列目、インデックス1）
print("数学の点数:", scores[:, 1])

# 3-4番目の生徒、国語と英語
# 行: インデックス2と3、列: インデックス0と2
print("3-4番目の国語と英語:")
print(scores[2:4, 0::2])  # 0::2 で 0列目と2列目

# 数学80点以上の生徒
# まず数学の点数でブールマスクを作成
math_scores = scores[:, 1]
mask = math_scores >= 80
print("数学80点以上:")
print(scores[mask])
```

**別解: 列を個別に指定**

```python
# 3-4番目の国語と英語（列を個別指定）
subset = scores[2:4][:, [0, 2]]
print(subset)
```

</details>

---

## 応用問題2: 画像データの操作

### 問題

グレースケール画像を表す 6×6 の配列があります（値 0-255）。

```python
import numpy as np

image = np.array([[100, 120, 130, 140, 150, 160],
                  [110, 130, 140, 150, 160, 170],
                  [120, 140, 150, 160, 170, 180],
                  [130, 150, 160, 170, 180, 190],
                  [140, 160, 170, 180, 190, 200],
                  [150, 170, 180, 190, 200, 210]])
```

以下の操作を行ってください：

1. 画像を上下反転
2. 画像を左右反転
3. 中央の 2×2 の領域を抽出
4. 値が180以上のピクセルを255に変更（元の配列を変更しない）

### 期待される出力

```
上下反転:
[[150 170 180 190 200 210]
 [140 160 170 180 190 200]
 [130 150 160 170 180 190]
 [120 140 150 160 170 180]
 [110 130 140 150 160 170]
 [100 120 130 140 150 160]]
左右反転:
[[160 150 140 130 120 100]
 [170 160 150 140 130 110]
 [180 170 160 150 140 120]
 [190 180 170 160 150 130]
 [200 190 180 170 160 140]
 [210 200 190 180 170 150]]
中央2x2:
[[150 160]
 [160 170]]
180以上を255に:
[[100 120 130 140 150 160]
 [110 130 140 150 160 170]
 [120 140 150 160 170 255]
 [130 150 160 170 255 255]
 [140 160 170 255 255 255]
 [150 170 255 255 255 255]]
```

<details>
<summary>解答例を見る</summary>

**基本解法: スライスとブールインデックスを使用**

```python
import numpy as np

image = np.array([[100, 120, 130, 140, 150, 160],
                  [110, 130, 140, 150, 160, 170],
                  [120, 140, 150, 160, 170, 180],
                  [130, 150, 160, 170, 180, 190],
                  [140, 160, 170, 180, 190, 200],
                  [150, 170, 180, 190, 200, 210]])

# 上下反転: 行を逆順に
print("上下反転:")
print(image[::-1])

# 左右反転: 列を逆順に
print("左右反転:")
print(image[:, ::-1])

# 中央2x2: 行2-3、列2-3
print("中央2x2:")
print(image[2:4, 2:4])

# 180以上を255に（コピーを作成して変更）
print("180以上を255に:")
image_modified = image.copy()  # コピーを作成
image_modified[image_modified >= 180] = 255
print(image_modified)
```

</details>

---

## 応用問題3: データの正規化

### 問題

テストの点数を 0〜1 の範囲に正規化してください。

正規化の公式: $(値 - 最小値) / (最大値 - 最小値)$

```python
import numpy as np
np.random.seed(42)
scores = np.random.randint(30, 100, size=10)
```

1. 配列の最小値と最大値を求める
2. 正規化した配列を作成
3. 正規化後の最小値が0、最大値が1になっていることを確認

### 期待される出力

```
元の点数: [81 84 62 31 70 49 78 85 82 81]
最小値: 31, 最大値: 85
正規化後: [0.926 0.981 0.574 0.    0.722 0.333 0.870 1.    0.944 0.926]
正規化後の最小値: 0.0, 最大値: 1.0
```

<details>
<summary>解答例を見る</summary>

**基本解法: 四則演算で正規化**

```python
import numpy as np

np.random.seed(42)
scores = np.random.randint(30, 100, size=10)

print("元の点数:", scores)

# 最小値と最大値を手動で計算
min_val = scores[0]
max_val = scores[0]
for s in scores:
    if s < min_val:
        min_val = s
    if s > max_val:
        max_val = s

print(f"最小値: {min_val}, 最大値: {max_val}")

# 正規化（四則演算）
normalized = (scores - min_val) / (max_val - min_val)
print("正規化後:", normalized.round(3))

# 正規化後の最小値と最大値を確認
norm_min = normalized[0]
norm_max = normalized[0]
for n in normalized:
    if n < norm_min:
        norm_min = n
    if n > norm_max:
        norm_max = n
print(f"正規化後の最小値: {norm_min}, 最大値: {norm_max}")
```

**発展解法: NumPy の min/max を使用**

```python
import numpy as np

np.random.seed(42)
scores = np.random.randint(30, 100, size=10)

print("元の点数:", scores)

min_val = scores.min()
max_val = scores.max()
print(f"最小値: {min_val}, 最大値: {max_val}")

normalized = (scores - min_val) / (max_val - min_val)
print("正規化後:", normalized.round(3))
print(f"正規化後の最小値: {normalized.min()}, 最大値: {normalized.max()}")
```

</details>

---

## 応用問題4: 行列の枠を抽出

### 問題

5×5 の行列から、外側の枠（周囲の要素）だけを取り出してください。

```python
import numpy as np
arr = np.arange(1, 26).reshape(5, 5)
```

外側の枠とは、1行目、5行目、1列目、5列目の要素です。

### 期待される出力

```
元の配列:
[[ 1  2  3  4  5]
 [ 6  7  8  9 10]
 [11 12 13 14 15]
 [16 17 18 19 20]
 [21 22 23 24 25]]
外枠の要素: [ 1  2  3  4  5  6 10 11 15 16 20 21 22 23 24 25]
```

<details>
<summary>解答例を見る</summary>

**基本解法: スライスで各部分を取り出して結合**

```python
import numpy as np

arr = np.arange(1, 26).reshape(5, 5)
print("元の配列:")
print(arr)

# 外枠を構成する部分を取り出す
top = arr[0, :]           # 1行目全体
bottom = arr[-1, :]       # 最後の行全体
left = arr[1:-1, 0]       # 左端（上下を除く）
right = arr[1:-1, -1]     # 右端（上下を除く）

# 結合
frame = np.concatenate([top, left, right, bottom])
print("外枠の要素:", frame)
```

**発展解法: ブールマスクを使用**

```python
import numpy as np

arr = np.arange(1, 26).reshape(5, 5)
print("元の配列:")
print(arr)

# マスクを作成（Trueが外枠）
mask = np.ones((5, 5), dtype=bool)
mask[1:-1, 1:-1] = False  # 内側をFalseに

print("外枠の要素:", arr[mask])
```

</details>

---

## 応用問題5: 移動平均の計算

### 問題

株価データに対して、3日移動平均を計算してください。
移動平均とは、連続するn個のデータの平均値です。

```python
import numpy as np
prices = np.array([100, 102, 101, 105, 108, 107, 110, 112, 109, 115])
```

3日移動平均: (prices[i] + prices[i+1] + prices[i+2]) / 3

### 期待される出力

```
元の株価: [100 102 101 105 108 107 110 112 109 115]
3日移動平均: [101.   102.67 104.67 106.67 108.33 109.67 110.33 112.  ]
```
（小数点以下2桁で表示）

<details>
<summary>解答例を見る</summary>

**基本解法: for ループとスライスを使用**

```python
import numpy as np

prices = np.array([100, 102, 101, 105, 108, 107, 110, 112, 109, 115])
print("元の株価:", prices)

# 3日移動平均を計算
window = 3
n = len(prices) - window + 1  # 結果の要素数

# 結果を格納する配列
moving_avg = np.zeros(n)

for i in range(n):
    # i番目からwindow個の要素の平均
    moving_avg[i] = (prices[i] + prices[i+1] + prices[i+2]) / 3

print("3日移動平均:", moving_avg.round(2))
```

**発展解法: スライスのみで計算**

```python
import numpy as np

prices = np.array([100, 102, 101, 105, 108, 107, 110, 112, 109, 115])
print("元の株価:", prices)

# スライスを使って3日分のデータを取り出して平均
window = 3
n = len(prices) - window + 1

# 3つのスライスの平均
moving_avg = (prices[0:n] + prices[1:n+1] + prices[2:n+2]) / 3

print("3日移動平均:", moving_avg.round(2))
```

</details>

---

## 応用問題6: 行列のパディング

### 問題

3×3 の行列の周囲を 0 で埋めて 5×5 の行列にしてください。

```python
import numpy as np
arr = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])
```

### 期待される出力

```
元の配列:
[[1 2 3]
 [4 5 6]
 [7 8 9]]
パディング後:
[[0 0 0 0 0]
 [0 1 2 3 0]
 [0 4 5 6 0]
 [0 7 8 9 0]
 [0 0 0 0 0]]
```

<details>
<summary>解答例を見る</summary>

**基本解法: zeros 配列を作成してスライスで代入**

```python
import numpy as np

arr = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])
print("元の配列:")
print(arr)

# 5×5 のゼロ配列を作成
padded = np.zeros((5, 5), dtype=int)

# 中央部分に元の配列を代入
padded[1:4, 1:4] = arr

print("パディング後:")
print(padded)
```

**発展解法: np.pad を使用**

```python
import numpy as np

arr = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])
print("元の配列:")
print(arr)

# 上下左右に1つずつパディング
padded = np.pad(arr, pad_width=1, mode='constant', constant_values=0)
print("パディング後:")
print(padded)
```

</details>

---

## 🏆 チャレンジ問題: 画像のダウンサンプリング

### 問題

8×8 の画像を 4×4 にダウンサンプリングしてください。
2×2 のブロックごとに平均値を計算します。

```python
import numpy as np
np.random.seed(123)
image = np.random.randint(0, 256, size=(8, 8))
```

### 期待される出力例

```
元の画像 (8x8):
[[220 215 166  76 102  77  87 211]
 [196  65 206 165 130  20  62 148]
 [ 30 174 176 163 112  65 134 186]
 [ 35 236 193  93 126 132 120 200]
 ...
]
ダウンサンプリング後 (4x4):
[[174.  153.25  82.25 127.  ]
 [118.75 156.25 108.75 160.  ]
 ...
]
```

<details>
<summary>解答例を見る</summary>

**基本解法: for ループで 2×2 ブロックごとに処理**

```python
import numpy as np

np.random.seed(123)
image = np.random.randint(0, 256, size=(8, 8))
print("元の画像 (8x8):")
print(image)

# 4×4 の結果配列
downsampled = np.zeros((4, 4))

# 2×2 ブロックごとに平均を計算
for i in range(4):
    for j in range(4):
        # 2×2 ブロックを取り出す
        block = image[i*2:(i+1)*2, j*2:(j+1)*2]
        # 4要素の平均を計算
        total = block[0, 0] + block[0, 1] + block[1, 0] + block[1, 1]
        downsampled[i, j] = total / 4

print("ダウンサンプリング後 (4x4):")
print(downsampled)
```

**発展解法: reshape と mean を使用**

```python
import numpy as np

np.random.seed(123)
image = np.random.randint(0, 256, size=(8, 8))
print("元の画像 (8x8):")
print(image)

# (8,8) → (4,2,4,2) → axis=(1,3)で平均 → (4,4)
downsampled = image.reshape(4, 2, 4, 2).mean(axis=(1, 3))

print("ダウンサンプリング後 (4x4):")
print(downsampled)
```

</details>

---

すべての問題が解けたら、Section3 に進みましょう！
