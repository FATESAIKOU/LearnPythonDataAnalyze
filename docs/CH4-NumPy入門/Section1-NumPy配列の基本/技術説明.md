# Section1: NumPy 配列の基本

## 🎯 このセクションの目標

- NumPy が何かを理解する
- NumPy 配列（ndarray）を作成できるようになる
- 配列の基本的な属性（shape, dtype など）を理解する

---

## 📚 NumPy とは？

**NumPy**（ナムパイ）は、Python で数値計算を効率的に行うためのライブラリです。

### なぜ NumPy を使うのか？

Python のリストでも計算はできますが、NumPy を使うと：

1. **高速**: 大量のデータを高速に処理できる
2. **便利**: 配列同士の計算が簡単に書ける
3. **必須**: Pandas や Matplotlib の基礎になっている

```python
# Python リストの場合（面倒）
list_a = [1, 2, 3, 4, 5]
list_b = [10, 20, 30, 40, 50]
result = []
for i in range(len(list_a)):
    result.append(list_a[i] + list_b[i])
print(result)  # [11, 22, 33, 44, 55]

# NumPy の場合（簡単！）
import numpy as np
array_a = np.array([1, 2, 3, 4, 5])
array_b = np.array([10, 20, 30, 40, 50])
result = array_a + array_b
print(result)  # [11 22 33 44 55]
```

---

## 🔧 NumPy のインポート

NumPy を使うには、まずインポートします。慣例として `np` という短い名前で使います。

```python
import numpy as np
```

> 💡 `np` という名前は世界中の Python プログラマーが使う慣例です。他の名前でも動きますが、`np` を使うことをお勧めします。

---

## 📦 NumPy 配列の作成

### 基本: リストから配列を作成

`np.array()` 関数を使って、Python のリストから NumPy 配列を作成します。

```python
import numpy as np

# 1次元配列
arr1 = np.array([1, 2, 3, 4, 5])
print(arr1)
# 出力: [1 2 3 4 5]

# 2次元配列（行列）
arr2 = np.array([[1, 2, 3],
                 [4, 5, 6]])
print(arr2)
# 出力:
# [[1 2 3]
#  [4 5 6]]
```

> 💡 配列の表示にはカンマ（,）がないことに注目してください。これがリストとの見た目の違いです。

---

## 📐 配列の属性

NumPy 配列には様々な属性があります。よく使う4つを覚えましょう。

```python
import numpy as np

arr = np.array([[1, 2, 3],
                [4, 5, 6]])

# 形状（何行何列か）
print(arr.shape)   # (2, 3) → 2行3列

# 次元数
print(arr.ndim)    # 2 → 2次元

# 要素の総数
print(arr.size)    # 6 → 2×3=6個

# データ型
print(arr.dtype)   # int64（環境により異なる場合あり）
```

### shape の読み方

```
shape = (2, 3)
         ↓  ↓
        行  列
        
  列→  0   1   2
行↓  ┌───┬───┬───┐
 0   │ 1 │ 2 │ 3 │
     ├───┼───┼───┤
 1   │ 4 │ 5 │ 6 │
     └───┴───┴───┘
```

---

## 🔢 データ型（dtype）

NumPy 配列は、すべての要素が同じデータ型を持ちます。

| dtype | 説明 | 例 |
|-------|------|-----|
| `int64` | 整数（64ビット） | 1, 2, -3 |
| `float64` | 浮動小数点数（64ビット） | 1.5, 3.14 |
| `bool` | 真偽値 | True, False |
| `str` / `<U...` | 文字列 | 'hello' |

```python
import numpy as np

# 整数配列
int_arr = np.array([1, 2, 3])
print(int_arr.dtype)  # int64

# 浮動小数点配列（小数が含まれると自動的に float に）
float_arr = np.array([1.0, 2.5, 3.14])
print(float_arr.dtype)  # float64

# dtype を指定して作成
specified_arr = np.array([1, 2, 3], dtype=float)
print(specified_arr)       # [1. 2. 3.]
print(specified_arr.dtype) # float64
```

---

## 🛠️ 便利な配列作成関数

リストから作成する以外にも、便利な関数があります。

### np.zeros() - すべて 0 の配列

```python
import numpy as np

# 1次元
zeros_1d = np.zeros(5)
print(zeros_1d)  # [0. 0. 0. 0. 0.]

# 2次元（3行4列）
zeros_2d = np.zeros((3, 4))
print(zeros_2d)
# [[0. 0. 0. 0.]
#  [0. 0. 0. 0.]
#  [0. 0. 0. 0.]]
```

### np.ones() - すべて 1 の配列

```python
import numpy as np

ones_arr = np.ones((2, 3))
print(ones_arr)
# [[1. 1. 1.]
#  [1. 1. 1.]]
```

### np.arange() - 連番の配列

Python の `range()` に似ていますが、配列を返します。

```python
import numpy as np

# 0から9まで
arr1 = np.arange(10)
print(arr1)  # [0 1 2 3 4 5 6 7 8 9]

# 1から10まで
arr2 = np.arange(1, 11)
print(arr2)  # [ 1  2  3  4  5  6  7  8  9 10]

# 0から10まで、2刻み
arr3 = np.arange(0, 10, 2)
print(arr3)  # [0 2 4 6 8]

# 小数も使える
arr4 = np.arange(0, 1, 0.1)
print(arr4)  # [0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]
```

### np.linspace() - 等間隔に分割

開始値から終了値までを、指定した個数に等間隔で分割します。

```python
import numpy as np

# 0から10までを5等分
arr = np.linspace(0, 10, 5)
print(arr)  # [ 0.   2.5  5.   7.5 10. ]

# 0から1までを11等分（0.1刻み）
arr2 = np.linspace(0, 1, 11)
print(arr2)  # [0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. ]
```

> 💡 `arange` と `linspace` の違い：
> - `arange`: **刻み幅**を指定
> - `linspace`: **個数**を指定

---

## 🎲 乱数配列

データ分析では、テスト用のランダムなデータが必要になることがあります。

```python
import numpy as np

# 0以上1未満の乱数（一様分布）
rand_arr = np.random.rand(5)
print(rand_arr)  # 例: [0.123 0.456 0.789 0.234 0.567]

# 0以上1未満の乱数（2次元）
rand_2d = np.random.rand(2, 3)
print(rand_2d)
# 例:
# [[0.12 0.34 0.56]
#  [0.78 0.90 0.12]]

# 整数の乱数（0以上10未満）
randint_arr = np.random.randint(0, 10, size=5)
print(randint_arr)  # 例: [3 7 2 8 1]

# 正規分布（平均0、標準偏差1）
normal_arr = np.random.randn(5)
print(normal_arr)  # 例: [-0.5 1.2 -0.3 0.8 -1.1]
```

### 再現性のある乱数（シード）

同じ乱数を再現したい場合は、シードを設定します。

```python
import numpy as np

np.random.seed(42)  # シードを固定
print(np.random.rand(3))  # [0.37454012 0.95071431 0.73199394]

np.random.seed(42)  # 同じシードを設定
print(np.random.rand(3))  # [0.37454012 0.95071431 0.73199394]  ← 同じ結果
```

---
## 🔢 配列同士の四則演算（図解）

NumPy の強力な機能の一つは、異なる形状の配列同士でも計算ができることです。
これを **ブロードキャスト** と呼びます。ここでは基本的なパターンを図で理解しましょう。

### パターン1: 同じ形状の配列同士

同じ形状の配列は、対応する要素同士で計算されます。

```
配列A           配列B           A + B
┌───┬───┬───┐   ┌───┬───┬───┐   ┌───┬───┬───┐
│ 1 │ 2 │ 3 │ + │10 │20 │30 │ = │11 │22 │33 │
└───┴───┴───┘   └───┴───┴───┘   └───┴───┴───┘
```

```python
import numpy as np

a = np.array([1, 2, 3])
b = np.array([10, 20, 30])
print(a + b)  # [11 22 33]
print(a * b)  # [10 40 90]
```

### パターン2: 配列 と スカラー（0次元）

スカラー（単一の数値）は、配列のすべての要素に適用されます。

```
配列A           スカラー        A * 10
┌───┬───┬───┐                   ┌────┬────┬────┐
│ 1 │ 2 │ 3 │  ×  10          = │ 10 │ 20 │ 30 │
└───┴───┴───┘                   └────┴────┴────┘

↓ スカラーが配列全体に「広がる」イメージ

┌───┬───┬───┐   ┌────┬────┬────┐   ┌────┬────┬────┐
│ 1 │ 2 │ 3 │ × │ 10 │ 10 │ 10 │ = │ 10 │ 20 │ 30 │
└───┴───┴───┘   └────┴────┴────┘   └────┴────┴────┘
```

```python
import numpy as np

a = np.array([1, 2, 3])
print(a * 10)   # [10 20 30]
print(a + 5)    # [6 7 8]
print(a ** 2)   # [1 4 9]
```

### パターン3: 2次元配列 と 1次元配列

1次元配列は、2次元配列の各行に対して適用されます。

```
2次元配列A                1次元配列B       A + B
┌───┬───┬───┐             ┌───┬───┬───┐
│ 1 │ 2 │ 3 │             │10 │20 │30 │
├───┼───┼───┤      +      └───┴───┴───┘
│ 4 │ 5 │ 6 │
└───┴───┴───┘

↓ 1次元配列が各行に「広がる」イメージ

┌───┬───┬───┐   ┌────┬────┬────┐   ┌────┬────┬────┐
│ 1 │ 2 │ 3 │   │ 10 │ 20 │ 30 │   │ 11 │ 22 │ 33 │
├───┼───┼───┤ + ├────┼────┼────┤ = ├────┼────┼────┤
│ 4 │ 5 │ 6 │   │ 10 │ 20 │ 30 │   │ 14 │ 25 │ 36 │
└───┴───┴───┘   └────┴────┴────┘   └────┴────┴────┘
```

```python
import numpy as np

a = np.array([[1, 2, 3],
              [4, 5, 6]])
b = np.array([10, 20, 30])

print(a + b)
# [[11 22 33]
#  [14 25 36]]
```

### パターン4: 2次元配列 と 縦ベクトル

縦ベクトル（列ベクトル）は、各列に対して適用されます。

```
2次元配列A                縦ベクトルB       A * B
┌───┬───┬───┐             ┌───┐
│ 1 │ 2 │ 3 │             │10 │
├───┼───┼───┤      ×      ├───┤
│ 4 │ 5 │ 6 │             │20 │
└───┴───┴───┘             └───┘

↓ 縦ベクトルが各列に「広がる」イメージ

┌───┬───┬───┐   ┌────┬────┬────┐   ┌────┬────┬────┐
│ 1 │ 2 │ 3 │   │ 10 │ 10 │ 10 │   │ 10 │ 20 │ 30 │
├───┼───┼───┤ × ├────┼────┼────┤ = ├────┼────┼────┤
│ 4 │ 5 │ 6 │   │ 20 │ 20 │ 20 │   │ 80 │100 │120 │
└───┴───┴───┘   └────┴────┴────┘   └────┴────┴────┘
```

```python
import numpy as np

a = np.array([[1, 2, 3],
              [4, 5, 6]])
b = np.array([[10],
              [20]])  # shape: (2, 1)

print(a * b)
# [[ 10  20  30]
#  [ 80 100 120]]
```

### パターン5: 縦ベクトル と 横ベクトル（外積的な計算）

縦ベクトルと横ベクトルを計算すると、2次元配列が生成されます。

```
縦ベクトル      横ベクトル              結果
  ┌───┐
  │ 1 │        ┌───┬───┬───┐
  ├───┤   ×    │10 │20 │30 │
  │ 2 │        └───┴───┴───┘
  ├───┤
  │ 3 │
  └───┘

↓ 全組み合わせで計算

                        ┌────┬────┬────┐
  1 × [10,20,30]   →    │ 10 │ 20 │ 30 │
                        ├────┼────┼────┤
  2 × [10,20,30]   →    │ 20 │ 40 │ 60 │
                        ├────┼────┼────┤
  3 × [10,20,30]   →    │ 30 │ 60 │ 90 │
                        └────┴────┴────┘
```

```python
import numpy as np

a = np.array([[1],
              [2],
              [3]])  # shape: (3, 1)
b = np.array([10, 20, 30])  # shape: (3,)

print(a * b)
# [[10 20 30]
#  [20 40 60]
#  [30 60 90]]
```

> 💡 この仕組みを使って、九九の表も簡単に作れます！

### ブロードキャストのルール（簡易版）

1. 形状を右端から比較する
2. 各次元が「同じ」か「どちらかが1」なら計算可能
3. サイズ1の次元が、もう一方のサイズに「引き伸ばされる」

```
形状 (2, 3) と (3,)   → OK！ (3,) が各行に適用
形状 (2, 3) と (2, 1) → OK！ (2, 1) が各列に適用
形状 (2, 3) と (2,)   → NG！ 3 と 2 が合わない
```

---
## � まとめ

| 操作 | コード例 |
|------|----------|
| インポート | `import numpy as np` |
| 配列作成 | `np.array([1, 2, 3])` |
| 形状確認 | `arr.shape` |
| 次元数確認 | `arr.ndim` |
| 要素数確認 | `arr.size` |
| データ型確認 | `arr.dtype` |
| すべて0 | `np.zeros((2, 3))` |
| すべて1 | `np.ones((2, 3))` |
| 連番 | `np.arange(10)` |
| 等間隔 | `np.linspace(0, 1, 11)` |
| 乱数 | `np.random.rand(5)` |

---

## 🤔 よくある質問

### Q: リストと配列、どちらを使えばいい？

**A**: 数値計算をするなら NumPy 配列、それ以外はリストで OK です。

### Q: shape の (2, 3) と (3, 2) は違うの？

**A**: はい、全く違います！
- `(2, 3)`: 2行3列（横に長い）
- `(3, 2)`: 3行2列（縦に長い）

### Q: dtype は指定しなくていいの？

**A**: 通常は NumPy が自動で適切な型を選んでくれます。特殊な場合（メモリ節約など）のみ指定します。
